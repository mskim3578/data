import pickle;
with open('model/cloths_model_hist', 'wb') as file_pi:
        pickle.dump(history.history, file_pi)
################
#read model, history, test_df
from keras.models import load_model

model = load_model('model/color_cloths.keras')
history = pickle.load(open('model/cloths_model_hist', "rb"))



import matplotlib.pyplot as plt
batch = next(train_generator)
image,level = batch[0],batch[1]
image.shape
level.shape
plt.imshow(image[0])
level[0]


#테스트 데이터를 이용하여 예측하기
test_datagen = ImageDataGenerator(rescale = 1./255) #정규화
test_generator = test_datagen.flow_from_dataframe(
        dataframe=test_df,     directory=None,
        x_col = 'image',       y_col = None, #레이블 없음.
        target_size = (112, 112),   color_mode='rgb',
        class_mode=None,   #레이블 없음  
        batch_size=batch_size, #32
        shuffle = False)
#예측하기

test_df = pd.read_csv("./colordata/test.csv")
test_df.info()
class_col = list(test_df.columns[1:])
batch_size=32

plt.figure(figsize=(12, 4))
plt.subplot(1, 2, 1)
plt.plot(history['loss'], 'b-', label='loss')
plt.plot(history['val_loss'], 'r--', label='val_loss')
plt.xlabel('Epoch')
plt.legend()
plt.subplot(1, 2, 2)
plt.plot(history['acc'], 'g-', label='accuracy')
plt.plot(history['val_acc'], 'k--', label='val_accuracy')
plt.xlabel('Epoch')
plt.legend()
plt.show()


#테스트 데이터를 이용하여 예측하기
test_datagen = ImageDataGenerator(rescale = 1./255) #정규화
test_generator = test_datagen.flow_from_dataframe(
        dataframe=test_df,     
        directory=None,
        x_col = 'image',       
        y_col = None, #레이블 없음.
        target_size = (112, 112),   
        color_mode='rgb',
        class_mode=None,   #레이블 없음  
        batch_size=batch_size, #32
        shuffle = False)
#예측하기
preds = model.predict(test_generator, steps = 32)
preds[0] #9.9783474e-01, 3.8876748e-04, 8.1772832e-03, ....
off = 8
do_preds = preds[off:off+8] #8개씩 이미지 조회


for i, pred in enumerate(do_preds):
    plt.subplot(2, 4, i + 1) #2행4열이미지
    prob = zip(class_col,list(pred)) #(black,9.9.... ),...
    # print(list(x[1] for x in prob ))
   
    #정렬하기. 예측된 결과값으로 내림차순 정렬
    #prob : 11개의 컬럼의 값중 값이 큰 2개의 데이터
    # z[0]:class_col, z[1]: list(pred)
    prob = sorted(list(prob),\
                  key=lambda z : z[1], reverse=True)[:2]
    image = plt.imread(test_df["image"][i+off])
    plt.imshow(image) 
   
    plt.title(f'{prob[0][0]}:\
{round(prob[0][1] * 100,2):.2f}%\n{prob[1][0]}:{round(prob[1][1] *100,2):.2f}%', fontsize=9)
    plt.tight_layout()              
plt.show()



=================
model = Sequential([
    Conv2D(input_shape=(112, 112, 3),kernel_size=(3,3),
                   filters=32, padding='same', activation='relu'),
    Conv2D(kernel_size=(3,3), filters=64, padding='same',
                                               activation='relu'),
    MaxPool2D(pool_size=(2,2)),
    Dropout(rate=0.5), 
    Conv2D(kernel_size=(3,3), filters=128, 
           padding='same',activation='relu'),
    Conv2D(kernel_size=(3,3), filters=256, padding='valid',
           activation='relu'),
    MaxPool2D(pool_size=(2,2)),
    Dropout(rate=0.5),
    Flatten(), #평탄화층(레이어).1차원형태의 배열로 변경 
    Dense(units=512, activation='relu'),
    Dropout(rate=0.5),
    Dense(units=256, activation='relu'),
    Dropout(rate=0.5),
    Dense(units=11, activation='sigmoid') #출력층. 11개의 값
])                            
model.summary()



#########################################################
# 저장된 파일을 읽어서 데이터 분석하기
# console restart
import pandas as pd
train_df = pd.read_csv("./colordata/train.csv")
train_df.info()
val_df = pd.read_csv("./colordata/val.csv")
val_df.info()
test_df = pd.read_csv("./colordata/test.csv")
test_df.info()


#####################################################

#csv 파일을 위한 DataFrame 생성
train_df = pd.DataFrame(    
{'image':train_x, 'black':train_y[:, 0], 'blue':train_y[:, 1],
'brown':train_y[:, 2], 'green':train_y[:, 3], 'red':train_y[:, 4],
'white':train_y[:, 5], 'dress':train_y[:, 6], 'shirt':train_y[:, 7],
'pants':train_y[:, 8], 'shorts':train_y[:, 9], 'shoes':train_y[:, 10]})
train_df.info()


val_df = pd.DataFrame(
{'image':val_x, 'black':val_y[:, 0], 'blue':val_y[:, 1],
'brown':val_y[:, 2], 'green':val_y[:, 3], 'red':val_y[:, 4],
'white':val_y[:, 5], 'dress':val_y[:, 6], 'shirt':val_y[:, 7],
'pants':val_y[:, 8], 'shorts':val_y[:, 9], 'shoes':val_y[:, 10]})
val_df.info()

test_df = pd.DataFrame(
{'image':test_x, 'black':test_y[:, 0], 'blue':test_y[:, 1],
'brown':test_y[:, 2], 'green':test_y[:, 3], 'red':test_y[:, 4],
'white':test_y[:, 5], 'dress':test_y[:, 6], 'shirt':test_y[:, 7],
'pants':test_y[:, 8], 'shorts':test_y[:, 9], 'shoes':test_y[:, 10]})
test_df.info()





#다중레이블 생성을 위한 함수.
def check_cc(color, clothes): #black,dress
#np.zeros(11,) : 요소의 갯수가 11개이고 값이 0인 1차원배열 생성    
    labels = np.zeros(11,)
    if(color == 'black'):       labels[0] = 1
    elif(color == 'blue'):      labels[1] = 1
    elif(color == 'brown'):     labels[2] = 1
    elif(color == 'green'):     labels[3] = 1
    elif(color == 'red'):       labels[4] = 1
    elif(color == 'white'):     labels[5] = 1
    #의류종류 설정
    if(clothes == 'dress'):     labels[6] = 1
    elif(clothes == 'shirt'):   labels[7] = 1
    elif(clothes == 'pants'):   labels[8] = 1
    elif(clothes == 'shorts'):  labels[9] = 1
    elif(clothes == 'shoes'):   labels[10] = 1
    return labels  #[10000010000]





https://www.kaggle.com/trolukovich/apparel-images-dataset


class_names=['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat',
         'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']


#절도검거율과cctv 회귀선과 산점도 출력하기
#회기선 구하기 (x, y, 차수)
fp1 = np.polyfit(data_result['소계'], data_result['절도검거율'], 2) 
f1=np.poly1d(fp1) #회귀선을 위한 함수
fx=np.linspace(500,4000,100)   



#data_result 데이터에 오차 컬럼을 추가하기
# 실제 검거율과 기대검거율의 차이의 절대값 저장
data_result["오차"]=np.abs(data_result["절도검거율"]-f1(data_result['소계']))
#오차의 내림차순으로 정렬하여 df_sort 데이터 저장
df_sort = data_result.sort_values(by="오차", ascending=False)
df_sort 






#seaborn 데이터에서 mpg 데이터 로드하기
'''
mpg : 연비
cylinders : 실린더 수
displacement : 배기량
horsepower : 출력
weight : 차량무게
acceleration : 가속능력
model_year : 출시년도
origin : 제조국
name : 모델명
'''



##################################################
# titanic 데이터셋 연습(데이터 전처리)
# seaborn 모듈에 저장된 데이터
'''
survived	생존여부
pclass	좌석등급 (숫자)
sex	성별 (male, female)
age	나이
sibsp	형제자매 + 배우자 인원수
parch: 	부모 + 자식 인원수
fare: 	요금
embarked	탑승 항구
class	좌석등급 (영문)
who	성별 (man, woman)
adult_male 성인남자여부 
deck	선실 고유 번호 가장 앞자리 알파벳
embark_town	탑승 항구 (영문)
alive	생존여부 (영문)
alone	혼자인지 여부
'''



############## function 연습문제
#3 map 방식
# 리스트의 각 요소에 10을 더하여 새로운 리스트를 작성하시요
# 1) 일반 함수
# 2) 람다 함수수 
mylist1=[1,2,3,4,5]
def add10(n) :
    return n+10

mylist2=list(map(add10, mylist1))
print(mylist2)


#4 map 람다방식 
mylist2=list(map(lambda n:n+10, mylist1))
print(mylist2)
[11, 12, 13, 14, 15]

#
# 리스트의 평균을 구해주는 함수 getMean를  구현 하시오 
# 1) 일반 함수
# 2) lambda 함수 

###---연습문제 2
def getMean(li) :
    if len(li)>0 :
        return sum(li)/len(li)
    else:
        return 0


list1 = [1,2,3,4,5,6]
print(getMean(list1))
print(getMean([]))

# lambda  p : 명령문 
getMean2 = lambda li : sum(li)/len(li) if len(li)>0 else 0
print(getMean2(list1))
print(getMean2([]))



df=pd.read_csv("data/jeju1.csv")
df.to_csv("data/df_jeju1.csv",index=False) #index 제외
df.to_csv("data/df_jeju2.csv")  #index 포함
#한개의 sheet 읽기
df = pd.read_excel\
("data/sales_2015.xlsx","january_2015",index_col=None)
type(df) #DataFrame 객체
df
df.info()
#전체 sheet를 읽음
df = pd.read_excel\
("data/sales_2015.xlsx",sheet_name=None,index_col=None)
df
type(df) #딕셔너리 객체 데이터 




###############
df = pd.DataFrame([[15,'남','서울중'],[17,'여','서울여고'],
                   [17,'남','서울고']])
df

df = pd.DataFrame([[15,'남','서울중'],[17,'여','서울여고'],
                   [17,'남','서울고']],
                  index=['홍길동','성춘향','이몽룡'],
                  columns=['나이','성별','학교'])    





8/20 연습문제 :
########################  연습문제 
'''
연습문제 3
           
*****    
 ****      
  ***      
   **      
    *      
'''  
h=5  
for i in range(h,0,-1) :
   print(" " * (h-i),end="") 
   print("*"*i)

for i in range(h,0,-1) :
    for j in range(h,0,-1) :
        if j <= i:
           print("*",end="") 
        else: 
           print(" ",end="") 

    print()

for i in range(0,h) :
    for j in range(0,h) :
        if j >= i:
           print("*",end="") 
        else: 
           print(" ",end="") 

    print()


'''
연습문제 4         
    *     
   **     
  ***      
 ****      
*****      

'''
h=5   
for i in range(1,h+1,1) :
   print(" " * (h-i),end="") 
   print("*"*i)
   
   
 ################## 연습문제 
#연습문제 1
#두개의 리스트 데이터를 각각 한개식 리스트트로 생성하기기

clist=['black','white']
slist=['S','M','L']
# [['black', 'S'], ['black', 'M'], ['black', 'L'], ['white', 'S'], ['white', 'M'], ['white', 'L']]

tlist=[]
for c in clist:
    for s in slist:
        tlist.append([c,s])
print(tlist)
  


########################  연습문제 



"10,20,50,60,30,40,50,60,30"


'ab4690cfvg342가1나1다0'

13, 50, 47, 67, 12, 34, 55, 134, 85, -41, -85, -36

# 키보드에서 초를 입력받아 몇시간 몇분 몇초인지 출력하기
# input함수:키보드에서 입력받기.
#           문자열형태로 입력받음.

second = int(input("초를 입력하세요:"))
print(second//3600,"시간",(second%3600)//60,"분",\
      (second%60),"초")
    
# 연습문제 2 : 
# 금액(3650)을 입력 받아 잔돈(500,100,50,1)으로 바꿔주는 프로그램을 작성 하기 
# input함수:키보드에서 입력받기.
#           문자열형태로 입력받음.


money = int(input("금액을 입력하세요:"))
print("500원 동전의 갯수", money//500) 
print("100원 동전의 갯수", money%500//100)
print("50원 동전의 갯수", money%100//50)
print("10원 동전의 갯수", money%50//10)
print("1원 동전의 갯수", money%10)
 
